{"version":3,"file":"fibrelite.js","sources":["../fibrelite.js"],"sourcesContent":["export default function fibrelite(asyncFunction) {\n\n    let currentThread;\n\n    /** Move an async function into its own thread.\n     *  @param {Function} asyncFunction  An (async) function to run in a Worker.\n     *  @public\n     */\n    const greenlet = (asyncFunction) => {\n\n        if (!this.cachedFn) {\n            this.cachedFn = \n            // Register our wrapper function as the message handler\n            'onmessage=(' + (\n                // userFunc() is the user-supplied async function\n                userFunc => e => {\n                    // Invoking within then() captures exceptions in userFunc() as rejections\n                    Promise.resolve(e.data[1]).then(\n                        userFunc.apply.bind(userFunc, userFunc)\n                    ).then(\n                        // success handler - callback(id, SUCCESS(0), result)\n                        d => { postMessage([e.data[0], 0, d]); },\n                        // error handler - callback(id, ERROR(1), error)\n                        e => { postMessage([e.data[0], 1, ''+e]); }\n                    );\n                }\n            ) + ')(' + asyncFunction + ')'  // pass user-supplied function to the closure\n        }\n\n        // Create an \"inline\" worker (1:1 at definition time)\n        let worker = new Worker(\n                // The URL is a pointer to a stringified function (as a blob object)\n                URL.createObjectURL(\n                    new Blob([this.cachedFn])\n                )\n            ),\n\n            // A simple counter is used to generate worker-global unique ID's for RPC:\n            currentId = 0,\n\n            // Outward-facing promises store their \"controllers\" (`[request, reject]`) here:\n            promises = {};\n\n        /** Handle RPC results/errors coming back out of the worker.\n         *  Messages coming from the worker take the form `[id, status, result]`:\n         *    id     - counter-based unique ID for the RPC call\n         *    status - 0 for success, 1 for failure\n         *    result - the result or error, depending on `status`\n         */\n        worker.onmessage = e => {\n            // invoke the promise's resolve() or reject() depending on whether there was an error.\n            promises[e.data[0]][e.data[1]](e.data[2]);\n\n            // ... then delete the promise controller\n            promises[e.data[0]] = null;\n        };\n\n        // Return a proxy function that forwards calls to the worker & returns a promise for the result.\n        return {\n            worker: worker,\n            fn : function(args) {\n                args = [].slice.call(arguments);\n                return new Promise(function() {\n                    // Add the promise controller to the registry\n                    promises[++currentId] = arguments;\n\n                    // Send an RPC call to the worker - call(id, params)\n                    worker.postMessage([currentId, args]);\n                });\n            }\n        };\n\n    }\n\n    this.prioritiseExecute = async (value) => {\n\n        if (currentThread === undefined) {\n            currentThread = greenlet(asyncFunction)\n            return currentThread.fn(value);\n        }\n        new Promise((resolve) => {\n            resolve(currentThread.worker.terminate()); \n        });\n        currentThread = greenlet(asyncFunction);\n        return currentThread.fn(value);\n        \n    }\n\n    this.execute = async (value) => {\n        if (currentThread === undefined) {\n            currentThread = greenlet(asyncFunction)\n            return currentThread.fn(value);\n        }\n        return currentThread.fn(value);\n    }\n\n    this.getCurrentWorker = () => {\n        return currentThread.worker;\n    }\n\n}\n\n"],"names":["asyncFunction","currentThread","greenlet","this","cachedFn","userFunc","e","Promise","resolve","data","then","apply","bind","d","postMessage","let","worker","Worker","URL","createObjectURL","Blob","currentId","promises","onmessage","fn","args","slice","call","arguments","prioritiseExecute","value","undefined","terminate","execute","getCurrentWorker"],"mappings":"eAAe,SAAmBA,OAE1BC,SAMEC,WAAYF,GAETG,EAAKC,WACND,EAAKC,SAEL,uBAEIC,mBAAYC,GAERC,QAAQC,QAAQF,EAAEG,KAAK,IAAIC,KACvBL,EAASM,MAAMC,KAAKP,EAAUA,IAChCK,cAEEG,GAAOC,aAAaR,EAAEG,KAAK,GAAI,EAAGI,cAElCP,GAAOQ,aAAaR,EAAEG,KAAK,GAAI,EAAG,GAAGH,QAG7C,KAAON,EAAgB,KAI/Be,IAAIC,EAAS,IAAIC,OAETC,IAAIC,gBACA,IAAIC,MAAMjB,EAAKC,aAKvBiB,EAAY,EAGZC,KAiBJ,OATAN,EAAOO,mBAAYjB,GAEfgB,EAAShB,EAAEG,KAAK,IAAIH,EAAEG,KAAK,IAAIH,EAAEG,KAAK,IAGtCa,EAAShB,EAAEG,KAAK,IAAM,OAKtBO,OAAQA,EACRQ,GAAK,SAASC,GAEV,OADAA,KAAUC,MAAMC,KAAKC,WACd,IAAIrB,QAAQ,WAEfe,IAAWD,GAAaO,UAGxBZ,EAAOF,aAAaO,EAAWI,SAO/CtB,KAAK0B,2BAA2BC,oCAE5B,YAAsBC,IAAlB9B,KACAA,EAAgBC,EAASF,IACJwB,GAAGM,KAE5B,IAAIvB,iBAASC,GACTA,EAAQP,EAAce,OAAOgB,kBAEjC/B,EAAgBC,EAASF,IACJwB,GAAGM,gBAI5B3B,KAAK8B,iBAAiBH,oCAClB,cAAsBC,IAAlB9B,GACAA,EAAgBC,EAASF,IACJwB,GAAGM,GAErB7B,EAAcuB,GAAGM,eAG5B3B,KAAK+B,mCACMjC,EAAce"}