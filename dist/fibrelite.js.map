{"version":3,"file":"fibrelite.js","sources":["../fibrelite.js"],"sourcesContent":["export default function fibrelite(asyncFunction, totalThreads) {\n\n    const pool = [];\n    this.roundRobin = 0;\n    this.totalThreads = totalThreads || 1;\n\n    // More than 20 web workers will crash most browsers\n    if (this.totalThreads > 20) {\n        this.totalThreads = 20;\n    }\n\n    // getThread is entirely based on Jason Millers Greenlet \n    // https://github.com/developit/greenlet\n\n    /** Move an async function into its own thread.\n     *  @param {Function} asyncFunction  An (async) function to run in a Worker.\n     *  @public\n     */\n    const getThread = (asyncFunction) => {\n\n        if (!this.cachedObjectUrl) {\n\n            // The URL is a pointer to a stringified function (as a blob object)\n            this.cachedObjectUrl = URL.createObjectURL(new Blob([\n                // Register our wrapper function as the message handler\n                'onmessage=(' + (\n                    // userFunc() is the user-supplied async function\n                    userFunc => e => {\n                        // Invoking within then() captures exceptions in userFunc() as rejections\n                        Promise.resolve(e.data[1]).then(\n                            userFunc.apply.bind(userFunc, userFunc)\n                        ).then(\n                            // success handler - callback(id, SUCCESS(0), result)\n                            d => { postMessage([e.data[0], 0, d]);},\n                            // error handler - callback(id, ERROR(1), error)\n                            e => { postMessage([e.data[0], 1, ''+e]); }\n                        );\n                    }\n                ) + ')(' + asyncFunction + ')'  // pass user-supplied function to the closure\n            ]))\n            \n        }\n\n        // Create an \"inline\" worker (1:1 at definition time)\n        let worker = new Worker(this.cachedObjectUrl),\n\n            // A simple counter is used to generate worker-global unique ID's for RPC:\n            currentId = 0,\n\n            // Outward-facing promises store their \"controllers\" (`[request, reject]`) here:\n            promises = {};\n\n\n        /** Handle RPC results/errors coming back out of the worker.\n         *  Messages coming from the worker take the form `[id, status, result]`:\n         *    id     - counter-based unique ID for the RPC call\n         *    status - 0 for success, 1 for failure\n         *    result - the result or error, depending on `status`\n         */\n\n        worker.onmessage = e => {\n\n            // invoke the promise's resolve() or reject() depending on whether there was an error.\n            promises[e.data[0]][e.data[1]](e.data[2])\n\n            // ... then delete the promise controller\n            promises[e.data[0]] = null;\n\n        };\n\n        // Return a proxy function that forwards calls to the worker & returns a promise for the result.\n        const thread = {\n            resolved: false,\n            worker: worker,\n            fn : function(args) {\n                args = [].slice.call(arguments);\n\n                return new Promise(function() {\n                    thread.resolved = false;\n                    // Add the promise controller to the registry\n                    promises[++currentId] = arguments;\n\n                    // Send an RPC call to the worker - call(id, params)\n                    worker.postMessage([currentId, args]);\n                }).then((result) => {\n                    thread.resolved = true;\n                    return result;\n                })\n            }\n        };\n        return thread;\n\n    }\n\n    this.waitExecute = async (value) => {\n\n        if (this.totalThreads === 1) {\n            if (\n                pool.length && \n                pool[0].resolved === false &&\n                this.lastKnownValue !== undefined\n            ) {\n                // If the oldest thread hasn't resolved\n                // just give back the last known value\n                return this.lastKnownValue;\n            }\n\n            if (!pool.length) pool[0] = getThread(asyncFunction);\n    \n            this.lastKnownValue = pool[0].fn(value);\n            return this.lastKnownValue;\n\n        } else {\n            throw Error(\"waitExecute requires only use of one worker\");\n        }\n\n    }\n\n    this.prioritiseExecute = async (value) => {\n\n        if (pool.length > 0) {\n            if (pool[this.totalThreads - 1].resolved === false) {\n                // Remove the worker from the pool\n                // and terminate it\n                pool.pop().worker.terminate();\n            }\n        }\n        \n        return this.execute(value);\n        \n    }\n\n    this.execute = async (value) => {\n\n        while (pool.length < this.totalThreads) {\n            pool.unshift(getThread(asyncFunction));\n        }\n\n        const thread = pool[this.roundRobin].fn(value);\n        if (this.roundRobin >= this.totalThreads - 1) {\n\n        } else {\n            this.roundRobin++;\n        }\n        return thread;\n\n    }\n\n    this.getCurrentWorker = () => {\n        return currentThread.worker;\n    }\n\n}\n\n"],"names":["asyncFunction","totalThreads","pool","this","roundRobin","const","getThread","cachedObjectUrl","URL","createObjectURL","Blob","userFunc","e","Promise","resolve","data","then","apply","bind","d","postMessage","let","worker","Worker","currentId","promises","onmessage","thread","resolved","fn","args","slice","call","arguments","result","waitExecute","value","length","undefined","lastKnownValue","Error","prioritiseExecute","pop","terminate","execute","unshift","getCurrentWorker","currentThread"],"mappings":"eAAe,SAAmBA,EAAeC,cAEvCC,KACNC,KAAKC,WAAa,EAClBD,KAAKF,aAAeA,GAAgB,EAGhCE,KAAKF,aAAe,KACpBE,KAAKF,aAAe,IAUxBI,IAAMC,WAAaN,GAEVG,EAAKI,kBAGNJ,EAAKI,gBAAkBC,IAAIC,gBAAgB,IAAIC,MAE3C,uBAEIC,mBAAYC,GAERC,QAAQC,QAAQF,EAAEG,KAAK,IAAIC,KACvBL,EAASM,MAAMC,KAAKP,EAAUA,IAChCK,cAEEG,GAAOC,aAAaR,EAAEG,KAAK,GAAI,EAAGI,cAElCP,GAAOQ,aAAaR,EAAEG,KAAK,GAAI,EAAG,GAAGH,QAG7C,KAAOZ,EAAgB,QAMnCqB,IAAIC,EAAS,IAAIC,OAAOpB,EAAKI,iBAGzBiB,EAAY,EAGZC,KAUJH,EAAOI,mBAAYd,GAGfa,EAASb,EAAEG,KAAK,IAAIH,EAAEG,KAAK,IAAIH,EAAEG,KAAK,IAGtCU,EAASb,EAAEG,KAAK,IAAM,MAK1BV,IAAMsB,GACFC,UAAU,EACVN,OAAQA,EACRO,GAAK,SAASC,GAGV,OAFAA,KAAUC,MAAMC,KAAKC,WAEd,IAAIpB,QAAQ,WACfc,EAAOC,UAAW,EAElBH,IAAWD,GAAaS,UAGxBX,EAAOF,aAAaI,EAAWM,MAChCd,cAAMkB,GAEL,OADAP,EAAOC,UAAW,EACXM,MAInB,OAAOP,GAIXxB,KAAKgC,qBAAqBC,oCAEtB,OAA0B,IAAtBjC,KAAKF,aAEDC,EAAKmC,SACgB,IAArBnC,EAAK,GAAG0B,eACgBU,IAAxBnC,KAAKoC,iBAIEpC,KAAKoC,iBAGXrC,EAAKmC,SAAQnC,EAAK,GAAKI,EAAUN,IAEtCG,KAAKoC,eAAiBrC,EAAK,GAAG2B,GAAGO,KAC1BjC,KAAKoC,mBAGNC,MAAM,2DAKpBrC,KAAKsC,2BAA2BL,oCAU5B,OARIlC,EAAKmC,OAAS,IAC+B,IAAzCnC,EAAKC,KAAKF,aAAe,GAAG2B,UAG5B1B,EAAKwC,MAAMpB,OAAOqB,cAInBxC,KAAKyC,QAAQR,eAIxBjC,KAAKyC,iBAAiBR,oCAElB,KAAOlC,EAAKmC,OAASlC,KAAKF,cACtBC,EAAK2C,QAAQvC,EAAUN,IAG3BK,IAAMsB,EAASzB,EAAKC,KAAKC,YAAYyB,GAAGO,GAMxC,OALIjC,KAAKC,YAAcD,KAAKF,aAAe,GAGvCE,KAAKC,eAEFuB,cAIXxB,KAAK2C,mCACMC,cAAczB"}