{"version":3,"file":"fibrelite.m.js","sources":["../fibrelite.js"],"sourcesContent":["export default function fibrelite(asyncFunction, totalThreads, debounce) {\n\n    const pool = [];\n    this.roundRobin = 0;\n    this.totalThreads = totalThreads || 1;\n    this.debounce = debounce || 333;\n    this.debounceId = 0; // Keep track of debounce calls\n    this.firstPrioritiseCall = true; // Prevent unecessary termination\n\n    // More than 20 web workers will crash most browsers\n    if (this.totalThreads > 20) {\n        this.totalThreads = 20;\n    }\n\n    // getThread is entirely based on Jason Millers Greenlet \n    // https://github.com/developit/greenlet\n\n    /** Move an async function into its own thread.\n     *  @param {Function} asyncFunction  An (async) function to run in a Worker.\n     *  @public\n     */\n    const getThread = (asyncFunction) => {\n        // A simple counter is used to generate worker-global unique ID's for RPC:\n        let currentId = 0;\n\n        // Outward-facing promises store their \"controllers\" (`[request, reject]`) here:\n        const promises = {};\n\n        // Create an \"inline\" worker (1:1 at definition time)\n        const worker = new Worker(\n            // Use a data URI for the worker's src. It inlines the target function and an RPC handler:\n            'data:,$$='+asyncFunction+';onmessage='+(e => {\n                /* global $$ */\n\n                // Invoking within then() captures exceptions in the supplied async function as rejections\n                Promise.resolve(e.data[1]).then(\n                    v => $$.apply($$, v)\n                ).then(\n                    // success handler - callback(id, SUCCESS(0), result)\n                    // if `d` is transferable transfer zero-copy\n                    d => {\n                        postMessage([e.data[0], 0, d], [d].filter(x => (\n                            (x instanceof ArrayBuffer) ||\n                            (x instanceof MessagePort) ||\n                            (x instanceof ImageBitmap)\n                        )));\n                    },\n                    // error handler - callback(id, ERROR(1), error)\n                    er => { postMessage([e.data[0], 1, '' + er]); }\n                );\n            })\n        );\n\n        const thread = {\n            resolved: false,\n            worker: worker,\n            fn : function() {\n                const args = [].slice.call(arguments);\n                return new Promise(function () {\n\n                    // Add the promise controller to the registry\n                    promises[++currentId] = arguments;\n\n                    // Send an RPC call to the worker - call(id, params)\n                    // The filter is to provide a list of transferables to send zero-copy\n                    worker.postMessage([currentId, args], args.filter(x => (\n                        (x instanceof ArrayBuffer) ||\n                        (x instanceof MessagePort) ||\n                        (x instanceof ImageBitmap)\n                    )));\n                });\n            }\n        };\n\n        /** Handle RPC results/errors coming back out of the worker.\n         *  Messages coming from the worker take the form `[id, status, result]`:\n         *    id     - counter-based unique ID for the RPC call\n         *    status - 0 for success, 1 for failure\n         *    result - the result or error, depending on `status`\n         */\n        worker.onmessage = e => {\n            // Set the current thread as resolved;\n            thread.resolved = true;\n            // invoke the promise's resolve() or reject() depending on whether there was an error.\n            promises[e.data[0]][e.data[1]](e.data[2]);\n\n            // ... then delete the promise controller\n            promises[e.data[0]] = null;\n        };\n\n        // Return the thread to the developer\n        return thread;\n\n    }\n\n    /** \n     * Debounce a series of calls to a Web Worker async function\n     * catching the last call in a given batched time frame\n     */\n    this.debounce = async function() {\n\n        const args = [].slice.call(arguments);\n\n        // If batch has expired\n        if (this.batchEnds === undefined || Date.now() >= this.batchEnds) {\n\n            // This describes the end of the \n            // current batch of incoming executions\n            this.batchEnds = Date.now() + this.debounce;\n\n        } \n\n        // Keep the last arguments on record\n        this.finalArgsInBatch = args;\n\n        return new Promise((resolve) => {\n            setTimeout(() => {\n\n                if (this.finalArgsInBatch === args || this.lastExecution === undefined) {\n\n                    this.lastExecution = this.execute.apply(this, this.finalArgsInBatch).then((result) => {\n                        // When we have a known result set it to\n                        // the resolved value\n                        this.lastKnownResult = result;\n                        return result;\n                    });\n\n                    // Resolve the new latest value function\n                    resolve(this.lastExecution);\n\n                }\n                \n                // If we have an intermittent known result, resolve that\n                if (this.lastKnownResult !== undefined) {\n                    resolve(this.lastKnownResult);\n                } \n\n                // Else lets just resolve to the currently executing\n                // function\n                resolve(this.lastExecution);\n\n            },  \n            this.batchEnds - Date.now()) // The time at which to execute\n\n        });\n\n    }.bind(this);\n\n    /** \n     * Kill off workers that were previously processing a request\n     * in turn prioritising the latest call\n     */\n    this.prioritise =  async function() {\n        if (!this.firstPrioritiseCall) {\n            this.terminateAll();\n        }  \n        this.firstPrioritiseCall = false;\n        return this.execute.apply(this, [].slice.call(arguments));\n    }.bind(this);\n    \n    /** \n     * Execute the function passed to fibrelite. This is the\n     * standard method to use.\n     */\n    this.execute = async function() {\n\n        const args = [].slice.call(arguments);\n\n        // Fill the thread pool\n        while (pool.length < this.totalThreads) {\n            pool.unshift(getThread(asyncFunction));\n        }\n\n        // Get the next thread\n        const thread = pool[this.roundRobin].fn.apply(null, args);\n\n        // Increment the thread counter\n        if (this.roundRobin >= this.totalThreads - 1) {\n            this.roundRobin = 0;\n        } else {\n            this.roundRobin++;\n        }\n\n        return thread;\n\n    }.bind(this);\n\n    /** \n     * Get the pool of workers that fibrelite is currently using\n     */\n    this.getWorkers = () => {\n        return pool.concat(); // return a copy of the array\n    }\n\n    /** \n     * Kill all the currently executing workers\n     */\n    this.terminateAll = () => {\n\n        if (pool.length > 0 && pool[this.totalThreads - 1].resolved === false) {\n\n            // Remove the worker from the pool\n            // and terminate it\n            pool.pop().worker.terminate();\n        }\n\n    }\n\n}\n\n"],"names":["asyncFunction","totalThreads","debounce","pool","this","roundRobin","debounceId","firstPrioritiseCall","const","getThread","let","currentId","promises","worker","Worker","e","Promise","resolve","data","then","v","$$","apply","d","postMessage","filter","x","ArrayBuffer","MessagePort","ImageBitmap","er","thread","resolved","fn","args","slice","call","arguments","onmessage","$args","undefined","batchEnds","Date","now","finalArgsInBatch","setTimeout","lastExecution","execute","result","lastKnownResult","bind","prioritise","terminateAll","length","unshift","getWorkers","concat","pop","terminate"],"mappings":"eAAe,SAAmBA,EAAeC,EAAcC,cAErDC,KACNC,KAAKC,WAAa,EAClBD,KAAKH,aAAeA,GAAgB,EACpCG,KAAKF,SAAWA,GAAY,IAC5BE,KAAKE,WAAa,EAClBF,KAAKG,qBAAsB,EAGvBH,KAAKH,aAAe,KACpBG,KAAKH,aAAe,IAUxBO,IAAMC,WAAaT,GAEfU,IAAIC,EAAY,EAGVC,KAGAC,EAAS,IAAIC,OAEf,YAAYd,EAAc,uBAAee,GAIrCC,QAAQC,QAAQF,EAAEG,KAAK,IAAIC,cACvBC,UAAKC,GAAGC,MAAMD,GAAID,KACpBD,cAGEI,GACIC,aAAaT,EAAEG,KAAK,GAAI,EAAGK,IAAKA,GAAGE,gBAAOC,UACrCA,aAAaC,aACbD,aAAaE,aACbF,aAAaG,yBAItBC,GAAQN,aAAaT,EAAEG,KAAK,GAAI,EAAG,GAAKY,QAK9CC,GACFC,UAAU,EACVnB,OAAQA,EACRoB,GAAK,WACDzB,IAAM0B,KAAUC,MAAMC,KAAKC,WAC3B,OAAO,IAAIrB,QAAQ,WAGfJ,IAAWD,GAAa0B,UAIxBxB,EAAOW,aAAab,EAAWuB,GAAOA,EAAKT,gBAAOC,UAC7CA,aAAaC,aACbD,aAAaE,aACbF,aAAaG,mBAuB9B,OAXAhB,EAAOyB,mBAAYvB,GAEfgB,EAAOC,UAAW,EAElBpB,EAASG,EAAEG,KAAK,IAAIH,EAAEG,KAAK,IAAIH,EAAEG,KAAK,IAGtCN,EAASG,EAAEG,KAAK,IAAM,MAInBa,GAQX3B,KAAKF,oCAAW,4CAENgC,KAAUC,MAAMC,KAAKG,GAc3B,YAXuBC,IAAnBpC,KAAKqC,WAA2BC,KAAKC,OAASvC,KAAKqC,aAInDrC,KAAKqC,UAAYC,KAAKC,MAAQvC,KAAKF,UAKvCE,KAAKwC,iBAAmBV,IAEjB,IAAIlB,iBAASC,GAChB4B,sBAEQzC,EAAKwC,mBAAqBV,QAA+BM,IAAvBpC,EAAK0C,gBAEvC1C,EAAK0C,cAAgB1C,EAAK2C,QAAQzB,MAAMlB,EAAMA,EAAKwC,kBAAkBzB,cAAM6B,GAIvE,OADA5C,EAAK6C,gBAAkBD,EAChBA,IAIX/B,EAAQb,EAAK0C,qBAKYN,IAAzBpC,EAAK6C,iBACLhC,EAAQb,EAAK6C,iBAKjBhC,EAAQb,EAAK0C,gBAGjB1C,EAAKqC,UAAYC,KAAKC,wBAI5BO,KAAK9C,MAMPA,KAAK+C,sCAAc,iCAKf,OAJK/C,KAAKG,qBACNH,KAAKgD,eAEThD,KAAKG,qBAAsB,IACpBH,KAAK2C,QAAQzB,MAAMlB,QAAS+B,MAAMC,KAAKG,mBAChDW,KAAK9C,MAMPA,KAAK2C,mCAAU,iCAKX,IAHAvC,IAAM0B,KAAUC,MAAMC,KAAKG,GAGpBpC,EAAKkD,OAASjD,KAAKH,cACtBE,EAAKmD,QAAQ7C,EAAUT,IAI3BQ,IAAMuB,EAAS5B,EAAKC,KAAKC,YAAY4B,GAAGX,MAAM,KAAMY,GASpD,OANI9B,KAAKC,YAAcD,KAAKH,aAAe,EACvCG,KAAKC,WAAa,EAElBD,KAAKC,eAGF0B,iBAETmB,KAAK9C,MAKPA,KAAKmD,6BACMpD,EAAKqD,UAMhBpD,KAAKgD,wBAEGjD,EAAKkD,OAAS,IAA8C,IAAzClD,EAAKC,EAAKH,aAAe,GAAG+B,UAI/C7B,EAAKsD,MAAM5C,OAAO6C"}