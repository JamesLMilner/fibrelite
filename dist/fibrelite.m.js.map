{"version":3,"file":"fibrelite.m.js","sources":["../fibrelite.js"],"sourcesContent":["export default function fibrelite(asyncFunction, maxThreads) {\n\n    const pool = [];\n    this.maxThreads = maxThreads || 1;\n    this.id = 0;\n\n    /** Move an async function into its own thread.\n     *  @param {Function} asyncFunction  An (async) function to run in a Worker.\n     *  @public\n     */\n    const greenlet = (asyncFunction) => {\n\n        const parent = this;\n\n        if (!this.cachedFn) {\n            this.cachedFn = \n            // Register our wrapper function as the message handler\n            'onmessage=(' + (\n                // userFunc() is the user-supplied async function\n                userFunc => e => {\n                    // Invoking within then() captures exceptions in userFunc() as rejections\n                    Promise.resolve(e.data[1]).then(\n                        userFunc.apply.bind(userFunc, userFunc)\n                    ).then(\n                        // success handler - callback(id, SUCCESS(0), result)\n                        d => { postMessage([e.data[0], 0, d]);},\n                        // error handler - callback(id, ERROR(1), error)\n                        e => { postMessage([e.data[0], 1, ''+e]); }\n                    )\n                }\n            ) + ')(' + asyncFunction + ')'  // pass user-supplied function to the closure\n        }\n\n        // Create an \"inline\" worker (1:1 at definition time)\n        let worker = new Worker(\n                // The URL is a pointer to a stringified function (as a blob object)\n                URL.createObjectURL(\n                    new Blob([this.cachedFn])\n                )\n            ),\n\n            // A simple counter is used to generate worker-global unique ID's for RPC:\n            currentId = 0,\n\n            // Outward-facing promises store their \"controllers\" (`[request, reject]`) here:\n            promises = {};\n\n        worker.resolved = false;\n        \n        /** Handle RPC results/errors coming back out of the worker.\n         *  Messages coming from the worker take the form `[id, status, result]`:\n         *    id     - counter-based unique ID for the RPC call\n         *    status - 0 for success, 1 for failure\n         *    result - the result or error, depending on `status`\n         */\n\n        worker.onmessage = e => {\n            // invoke the promise's resolve() or reject() depending on whether there was an error.\n            promises[e.data[0]][e.data[1]](e.data[2]);\n\n            // ... then delete the promise controller\n            promises[e.data[0]] = null;\n\n            // We don't have to terminate workers that are finished\n            worker.resolved = true;\n        };\n\n        // Return a proxy function that forwards calls to the worker & returns a promise for the result.\n        return {\n            id : this.id++,\n            worker: worker,\n            fn : function(args) {\n                args = [].slice.call(arguments);\n                return new Promise(function() {\n                    // Add the promise controller to the registry\n                    promises[++currentId] = arguments;\n\n                    // Send an RPC call to the worker - call(id, params)\n                    worker.resolved = false;\n                    worker.postMessage([currentId, args]);\n                });\n            }\n        };\n\n    }\n\n    this.roundRobin = 0;\n\n    this.prioritiseExecute = async (value) => {\n        \n        this.roundRobin++;\n\n        if (this.roundRobin >= maxThreads - 1) {\n            this.roundRobin = 0;\n        }\n\n        while (pool.length < maxThreads) {\n            pool.unshift(greenlet(asyncFunction));\n        }\n\n        const oldestThread = pool.pop();\n        new Promise((resolve) => {\n            resolve(oldestThread.worker.terminate()); \n        });\n        \n        return pool[this.roundRobin].fn(value);\n        \n    }\n\n    // this.prioritiseExecute = async (value) => {\n    //     roundRobin++;\n    //     if (roundRobin === maxThread - 1) {\n    //         roundRobin = 0;\n    //     }\n    //     if (pool.length === 0) {\n    //         const currentThread = greenlet(asyncFunction)\n    //         pool.push(currentThread);\n    //         return currentThread.fn(value);\n    //     }\n\n    //     if (pool.length === maxThreads) {\n    //         console.log(\"last thread\", pool[maxThreads - 1]);\n    //         if (pool[maxThreads - 1].worker.resolved === false) {\n    //             const oldestThread = pool.pop();\n    //             new Promise((resolve) => {\n    //                 resolve(oldestThread.worker.terminate()); \n    //             });\n    //         }\n    //     }\n\n    //     console.log(\"pool\", pool);\n    //     if (pool.length < maxThreads) {\n    //         pool.unshift(greenlet(asyncFunction));\n    //     }\n        \n    //     return pool[0].fn(value);\n        \n    // }\n\n    // this.execute = async (value) => {\n    //     if (currentThread === undefined) {\n    //         currentThread = greenlet(asyncFunction)\n    //         return currentThread.fn(value);\n    //     }\n    //     return currentThread.fn(value);\n    // }\n\n    this.getCurrentWorker = () => {\n        return currentThread.worker;\n    }\n\n}\n\n"],"names":["asyncFunction","maxThreads","pool","this","id","const","greenlet","cachedFn","userFunc","e","Promise","resolve","data","then","apply","bind","d","postMessage","let","worker","Worker","URL","createObjectURL","Blob","currentId","promises","resolved","onmessage","fn","args","slice","call","arguments","roundRobin","prioritiseExecute","value","length","unshift","oldestThread","pop","terminate","getCurrentWorker","currentThread"],"mappings":"eAAe,SAAmBA,EAAeC,cAEvCC,KACNC,KAAKF,WAAaA,GAAc,EAChCE,KAAKC,GAAK,EAMVC,IAAMC,WAAYN,GAITG,EAAKI,WACNJ,EAAKI,SAEL,uBAEIC,mBAAYC,GAERC,QAAQC,QAAQF,EAAEG,KAAK,IAAIC,KACvBL,EAASM,MAAMC,KAAKP,EAAUA,IAChCK,cAEEG,GAAOC,aAAaR,EAAEG,KAAK,GAAI,EAAGI,cAElCP,GAAOQ,aAAaR,EAAEG,KAAK,GAAI,EAAG,GAAGH,QAG7C,KAAOT,EAAgB,KAI/BkB,IAAIC,EAAS,IAAIC,OAETC,IAAIC,gBACA,IAAIC,MAAMpB,EAAKI,aAKvBiB,EAAY,EAGZC,KAuBJ,OArBAN,EAAOO,UAAW,EASlBP,EAAOQ,mBAAYlB,GAEfgB,EAAShB,EAAEG,KAAK,IAAIH,EAAEG,KAAK,IAAIH,EAAEG,KAAK,IAGtCa,EAAShB,EAAEG,KAAK,IAAM,KAGtBO,EAAOO,UAAW,IAKlBtB,GAAKD,EAAKC,KACVe,OAAQA,EACRS,GAAK,SAASC,GAEV,OADAA,KAAUC,MAAMC,KAAKC,WACd,IAAItB,QAAQ,WAEfe,IAAWD,GAAaQ,UAGxBb,EAAOO,UAAW,EAClBP,EAAOF,aAAaO,EAAWK,SAO/C1B,KAAK8B,WAAa,EAElB9B,KAAK+B,2BAA2BC,oCAQ5B,IANAhC,KAAK8B,aAED9B,KAAK8B,YAAchC,EAAa,IAChCE,KAAK8B,WAAa,GAGf/B,EAAKkC,OAASnC,GACjBC,EAAKmC,QAAQ/B,EAASN,IAG1BK,IAAMiC,EAAepC,EAAKqC,MAK1B,OAJA,IAAI7B,iBAASC,GACTA,EAAQ2B,EAAanB,OAAOqB,iBAGzBtC,EAAKC,KAAK8B,YAAYL,GAAGO,eA0CpChC,KAAKsC,mCACMC,cAAcvB"}